export class Path{__original;__path;__rootParts;constructor(path,root=!1){this.__original=path;let parsedPath="string"==typeof path?path.split("/"):path;parsedPath=parsedPath.filter(item=>""!==item);const rootParts="number"==typeof root?root:0;for(let i=0;i<parsedPath.length&&i>=0;i++)".."===parsedPath[i]&&(i>rootParts?(parsedPath.splice(i-1,2),i-=2):!1!==root&&(parsedPath.splice(i,1),i--));this.__path=parsedPath,this.__rootParts="boolean"==typeof root?root?parsedPath.length:0:root}get original(){return this.__original}get length(){return this.__path.length}get(index){return this.__path[index]}getName(){return this.__path[this.__path.length-1]}toString(){return this.__path.join("/")}toArray(){return this.__path}combine(path){return"string"==typeof path?new Path(this.__path.concat(path.split("/")),this.__rootParts):Array.isArray(path)?new Path(this.__path.concat(path),this.__rootParts):new Path(this.__path.concat(path.toArray()),this.__rootParts)}pop(){return this.__path.pop()}equals(path){const other="string"==typeof path||Array.isArray(path)?new Path(path):path;return this.length===other.length&&this.__path.every((item,index)=>item===other.get(index))}[globalThis.Symbol.iterator](){return this.__path[globalThis.Symbol.iterator]()}}