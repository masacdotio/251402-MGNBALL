export class RecipeTypeParser{__recipeManagementDomain;__parentControl;constructor(__recipeManagementDomain,__parentControl){this.__recipeManagementDomain=__recipeManagementDomain,this.__parentControl=__parentControl}async parse(recipeTypeName,recipeType){return recipeType||(recipeType=(await this.__getRecipeTypes([recipeTypeName]))[0]),await this.__parseRecipeType(recipeTypeName,recipeType)}__getRecipeTypes(names){return new Promise((resolve,reject)=>{if(!this.__recipeManagementDomain)return void reject(new Error(TcHmi.Log.buildMessage({code:TcHmi.Errors.ERROR,message:TcHmi.Errors[TcHmi.Errors.ERROR],reason:"No recipe management domain was specified.",domain:this.__parentControl?.getType()})));const recipeTypes=[];for(const name of names){const result=TcHmi.Server.RecipeManagement.getRecipeTypeEx(name,null,{domain:this.__recipeManagementDomain,parallel:!0},null,data=>{if(data.error===TcHmi.Errors.NONE&&data.value)recipeTypes.push(data.value),recipeTypes.length===names.length&&resolve(recipeTypes);else if(data.details)reject(new Error(TcHmi.Log.buildMessage(data.details)));else{let res={code:TcHmi.Errors.ERROR,message:TcHmi.Errors[TcHmi.Errors.ERROR],reason:"Unknown error occured while getting recipe type."};this.__parentControl&&(res.domain=this.__parentControl.getType()),reject(new Error(TcHmi.Log.buildMessage(res)))}});if(result.code!==TcHmi.Errors.NONE)return void reject(new Error(TcHmi.Log.buildMessage(result)))}})}async __parseRecipeType(recipeTypeName,recipeType){const parsed={name:recipeTypeName,ungroupedMembers:[],memberGroups:new Map,membersEnabled:"Disabled"!==recipeType.options?.enabled,comment:recipeType.options?.comment},symbols=new Map,parse=async recipeType=>{for(const key in recipeType.members){const member=recipeType.members[key];if(!member)continue;let parsedMember;if(member.group){let group=parsed.memberGroups.get(member.group);group||(group=[],parsed.memberGroups.set(member.group,group)),parsedMember=tchmi_clone_object(member),parsedMember.name=key,parsedMember.enabled=(parsed.membersEnabled&&parsedMember.enabled)??!1,group.push(parsedMember)}else parsedMember=tchmi_clone_object(member),parsedMember.name=key,parsedMember.enabled=(parsed.membersEnabled&&parsedMember.enabled)??!1,parsed.ungroupedMembers.push(parsedMember);if("symbol"in parsedMember){const symbolsEntry=symbols.get(parsedMember.symbol);symbolsEntry?symbolsEntry.push(parsedMember):symbols.set(parsedMember.symbol,[parsedMember])}}if(recipeType.recipeTypeNames&&recipeType.recipeTypeNames.length>0){const bases=await this.__getRecipeTypes(recipeType.recipeTypeNames);for(const base of bases)await parse(base)}};await parse(recipeType);const schemas=await this.__getSchemas(new Set(symbols.keys()));for(const[symbol,schema]of schemas){const symbolMembers=symbols.get(symbol);if(symbolMembers)for(const symbolMember of symbolMembers)symbolMember.symbolType=schema}const sort=(a,b)=>void 0!==a.order&&void 0!==b.order?a.order-b.order:void 0===a.order&&void 0===b.order?a.name<b.name?-1:a.name>b.name?1:0:void 0!==a.order?-1:1;return parsed.ungroupedMembers.sort(sort),parsed.memberGroups.forEach(memberGroup=>memberGroup.sort(sort)),parsed.memberGroups=new Map(Array.from(parsed.memberGroups).sort(([_a,aMembers],[_b,bMembers])=>sort(aMembers[0],bMembers[0]))),parsed}__getSchemas(symbols){return 0===symbols.size?Promise.resolve(new Map):new Promise((resolve,reject)=>{const schemas=new Map;for(const symbol of symbols)TcHmi.Symbol.resolveSchema(`%s%${symbol}%/s%`,data=>{if(data.error!==TcHmi.Errors.NONE||!data.schema){const details=data.details||{code:data.error,message:TcHmi.Errors[data.error],domain:"TcHmi.Controls.Beckhoff.TcHmiRecipeEditComponents.RecipeTypeParser"};return void reject(new TcHmi.Exception(details))}schemas.set(symbol,data.schema),schemas.size===symbols.size&&resolve(schemas)})})}}