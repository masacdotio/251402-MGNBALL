import*as SystemSchema from"../System/Type.Schema.js";
/**
 * Generates a Javascript object or data primitive from the default values of a schema object.
 * Hint:
 * If you have a type definition string you can use TcHmi.Type.getSchema() API to get the schema object.
 * @param schema Schema so resolve
 * @preserve (Part of the public API)
 */export function resolveDefault(schema){return SystemSchema.resolveDefault(schema)}
/**
 * Resolves the effective type value/s of a schema except those with additional conversion rules.
 * Hint:
 * If you have a type definition string you can use TcHmi.Type.getSchema() API to get the schema object.
 * @param schema Schema to resolve
 * @preserve (Part of the public API)
 */export function resolveType(schema){return SystemSchema.resolveType(schema)}export function recurseThroughSchema(schema,data,action){const res=function iterateSchema(schema,subdata,path){const res=action(schema,subdata,path);if(res.changedValue)return res;let changedValue=!1;if(schema.properties&&"object"==typeof subdata&&null!==subdata)for(const[name,subSchema]of Object.entries(schema.properties))if(name in subdata&&subdata instanceof Object){const res=iterateSchema(subSchema,subdata[name],`${path?path+"::":""}properties::${name}`);res.changedValue&&(changedValue=!0,subdata[name]=res.value)}if(schema.items&&Array.isArray(subdata)&&subdata.length)if(Array.isArray(schema.items)){for(const[index,subSchema]of schema.items.entries())if(index in subdata){const res=iterateSchema(subSchema,subdata[index],`${path?path+"::":""}items[${index}]`);res.changedValue&&(changedValue=!0,subdata[index]=res.value)}}else for(const[dataindex,subdataentries]of subdata.entries()){const res=iterateSchema(schema.items,subdataentries,(path?path+"::":"")+"items");res.changedValue&&(changedValue=!0,subdata[dataindex]=res.value)}if(schema.anyOf)for(const[index,subSchema]of schema.anyOf.entries()){const res=iterateSchema(subSchema,subdata,`${path?path+"::":""}anyOf[${index}]`);res.changedValue&&(changedValue=!0,subdata=res.value)}if(schema.oneOf)for(const[index,subSchema]of schema.oneOf.entries()){const res=iterateSchema(subSchema,subdata,`${path?path+"::":""}oneOf[${index}]`);res.changedValue&&(changedValue=!0,subdata=res.value)}if(schema.allOf)for(const[index,subSchema]of schema.allOf.entries()){const res=iterateSchema(subSchema,subdata,`${path?path+"::":""}allOf[${index}]`);res.changedValue&&(changedValue=!0,subdata=res.value)}return{changedValue,value:subdata}}(schema,data,"");return res}export function matchesSchemaType(value,schema){const schemaTypes=resolveType(SystemSchema.resolveRefs(schema)??schema),valueType=typeof value;for(const schemaType of Array.isArray(schemaTypes)?schemaTypes:[schemaTypes])switch(schemaType){case"number":if(Number.isFinite(value))return!0;break;case"integer":if(Number.isInteger(value))return!0;break;case"array":if(Array.isArray(value))return!0;break;case"object":if("object"===valueType&&null!==value&&!Array.isArray(value))return!0;break;case"null":if(null==value)return!0;break;default:if(valueType===schemaType)return!0}const schemaConversionRules=SystemSchema.resolveTypeConvertRuleSchemaMap(schema);if(schemaConversionRules)for(const schemas of schemaConversionRules.values())for(const schema of schemas)switch(schema.convert){case"bigint64":case"unsignedbigint64":if("bigint"===valueType)return!0;break;default:if(valueType===schema.convert)return!0}return!1}TcHmi.Type??={},TcHmi.Type.Schema={resolveDefault,resolveType,recurseThroughSchema,matchesSchemaType};