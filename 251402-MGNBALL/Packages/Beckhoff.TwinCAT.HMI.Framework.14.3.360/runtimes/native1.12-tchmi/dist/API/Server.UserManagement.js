import{accessManager}from"../System/AccessManager.js";import{Data}from"../System/System.js";import{isParameterTypeInvalid,autoLogoffToMilliseconds}from"../System/SystemFunctions.js";import*as Server from"./Server.js";import{ACCESS as ServerACCESS}from"./Server.js";
/**
 * Add a new user with a given password
 * @param userName Username to add.
 * @param password Password for the new user.
 * @param callback Will be called after request.
 * @preserve (Part of the public API)
 */export function addUser(userName,password,callback=null){return addUserEx(userName,password,null,null,callback)}
/**
 * Add a new user with a given password
 * @param userName Username to add.
 * @param password Password for the new user.
 * @param options Optional details for this new user.
 * @param requestOptions Options for the request itself
 * @param callback Will be called after request.
 * @preserve (Part of the public API)
 */export function addUserEx(userName,password,options=null,requestOptions=null,callback=null){let paramInvalid=isParameterTypeInvalid(userName,"userName",{type:"string",required:"valueNeeded",minStringLength:1},"TcHmi.Server.UserManagement",callback);if(paramInvalid)return paramInvalid;if(paramInvalid=isParameterTypeInvalid(password,"password",{type:"string",required:"valueNeeded",minStringLength:1},"TcHmi.Server.UserManagement",callback),paramInvalid)return paramInvalid;const writeValue={domain:accessManager.getCurrentUserConfig().defaultAuthExtension,userName,parameters:{password},settings:{}};if(options){let paramInvalid=isParameterTypeInvalid(options.domain,"options.domain",{type:"string",required:"undefinedOk",minStringLength:1},"TcHmi.Server.UserManagement",callback);if(paramInvalid)return paramInvalid;if("string"==typeof options.domain&&options.domain.length>0&&(writeValue.domain=options.domain),paramInvalid=isParameterTypeInvalid(options.enabled,"options.enabled",{type:"boolean",required:"undefinedOk"},"TcHmi.Server.UserManagement",callback),paramInvalid)return paramInvalid;if("boolean"==typeof options.enabled&&(writeValue.parameters.enabled=options.enabled),paramInvalid=isParameterTypeInvalid(options.locale,"options.locale",{type:"string",required:"undefinedOk"},"TcHmi.Server.UserManagement",callback),paramInvalid)return paramInvalid;if(("string"==typeof options.locale&&options.locale.length>0||null===options.locale)&&(writeValue.settings.locale=options.locale),paramInvalid=isParameterTypeInvalid(options.timeFormatLocale,"options.timeFormatLocale",{type:"string",required:"undefinedOk"},"TcHmi.Server.UserManagement",callback),paramInvalid)return paramInvalid;if(("string"==typeof options.timeFormatLocale&&options.timeFormatLocale.length>0||null===options.timeFormatLocale)&&(writeValue.settings.timeFormatLocale=options.timeFormatLocale),paramInvalid=isParameterTypeInvalid(options.timeZone,"options.timeFormatLocale",{type:"string",required:"undefinedOk"},"TcHmi.Server.UserManagement",callback),paramInvalid)return paramInvalid;if(("string"==typeof options.timeZone&&options.timeZone.length>0||null===options.timeZone)&&(writeValue.settings.timeZone=options.timeZone),paramInvalid=isParameterTypeInvalid(options.autoLogout,"options.autoLogout",{type:"string",required:"undefinedOk"},"TcHmi.Server.UserManagement",callback),paramInvalid)return paramInvalid;if("string"==typeof options.autoLogout&&options.autoLogout.length>0&&(writeValue.settings.autoLogoff=options.autoLogout),paramInvalid=isParameterTypeInvalid(options.groups,"options.groups",{type:"string",expectArray:!0,required:"undefinedOk"},"TcHmi.Server.UserManagement",callback),paramInvalid)return paramInvalid;options.groups&&(writeValue.settings.groups=options.groups)}const request={requestType:"ReadWrite",commands:[{commandOptions:["SendErrorMessage"],symbol:"AddOrChangeUser",writeValue}]};if(null===Server.requestEx(request,requestOptions,Server.handleResponse({error:data=>{if(data.error===TcHmi.Errors.NONE&&data.results){let res=data.results[0];TcHmi.Callback.callSafeEx(callback,null,{error:res.error,details:res.details})}else TcHmi.Callback.callSafeEx(callback,null,{error:data.error,details:data.details})},success:()=>{TcHmi.Callback.callSafeEx(callback,null,{error:TcHmi.Errors.NONE})}}))){const errorDetail={code:TcHmi.Errors.ERROR,message:TcHmi.Errors[TcHmi.Errors.ERROR],reason:"Request could not be sent.",domain:"TcHmi.Server.UserManagement"};return TcHmi.Callback.callSafeEx(callback,null,{error:errorDetail.code,details:errorDetail}),errorDetail}return{code:TcHmi.Errors.NONE}}
/**
 * Lists all usernames as a string array
 * @param callback Will be called after request.
 * @preserve (Part of the public API)
 */export function listUsernames(callback=null){return listUsernamesEx(null,null,callback)}
/**
 * Lists all usernames as a string array
 * @param options Options
 * @param requestOptions Options for the request itself
 * @param callback Will be called after request.
 * @preserve (Part of the public API)
 */export function listUsernamesEx(options,requestOptions=null,callback=null){let domain=accessManager.getCurrentUserConfig().defaultAuthExtension;if(options){let paramInvalid=isParameterTypeInvalid(options.domain,"options.domain",{type:"string",required:"undefinedOk",minStringLength:1},"TcHmi.Server.UserManagement",callback);if(paramInvalid)return paramInvalid;"string"==typeof options.domain&&options.domain.length>0&&(domain=options.domain)}if(null===Server.requestEx({requestType:"ReadWrite",commands:[{commandOptions:["SendErrorMessage"],symbol:"ListUserNames"}]},requestOptions,Server.handleResponse({error:data=>{if(data.error===TcHmi.Errors.NONE&&data.results){let res=data.results[0];TcHmi.Callback.callSafeEx(callback,null,{error:res.error,details:res.details})}else TcHmi.Callback.callSafeEx(callback,null,{error:data.error,details:data.details})},success:data=>{if(data.results[0].value){let userList=[],isDefaultAuthExtension=domain===accessManager.getCurrentUserConfig().defaultAuthExtension;for(const user of data.results[0].value){let userAndDomain=user.split("::");isDefaultAuthExtension&&1===userAndDomain.length?userList.push(userAndDomain[0]):isDefaultAuthExtension||2!==userAndDomain.length||userAndDomain[0]!==domain||userList.push(userAndDomain[1])}TcHmi.Callback.callSafeEx(callback,null,{error:TcHmi.Errors.NONE,userList})}else TcHmi.Callback.callSafeEx(callback,null,{error:TcHmi.Errors.NONE,userList:void 0})}}))){const errorDetail={code:TcHmi.Errors.ERROR,message:TcHmi.Errors[TcHmi.Errors.ERROR],reason:"Request could not be sent.",domain:"TcHmi.Server.UserManagement"};return TcHmi.Callback.callSafeEx(callback,null,{error:errorDetail.code,details:errorDetail}),errorDetail}return{code:TcHmi.Errors.NONE}}
/**
 * Lists all username as a dictionary with all meta data
 * @param callback Will be called after request.
 * @preserve (Part of the public API)
 */export function listUsers(callback=null){return listUsersEx(null,null,callback)}
/**
 * Lists all username as a dictionary with all meta data
 * @param options Options
 * @param requestOptions Options for the request itself
 * @param callback Will be called after request.
 * @preserve (Part of the public API)
 */export function listUsersEx(options,requestOptions=null,callback=null){let domain=accessManager.getCurrentUserConfig().defaultAuthExtension;if(options){let paramInvalid=isParameterTypeInvalid(options.domain,"options.domain",{type:"string",required:"undefinedOk",minStringLength:1},"TcHmi.Server.UserManagement",callback);if(paramInvalid)return paramInvalid;"string"==typeof options.domain&&options.domain.length>0&&(domain=options.domain)}const request={requestType:"ReadWrite",commands:[{commandOptions:["SendErrorMessage"],symbol:domain+".ListDisabledUsers"}]},listUsersV2Available=Data.Caches.serverSymbolMetaDataCache.get("ListUsers")?.ListSymbols?.VERSIONS?.includes(2);listUsersV2Available?request.commands.push({commandOptions:["SendErrorMessage"],symbol:"ListUsers",version:2}):request.commands.push({commandOptions:["SendErrorMessage"],symbol:"TcHmiSrv.Config::USERGROUPUSERS::"+domain});if(null===Server.requestEx(request,requestOptions,Server.handleResponse({completed:data=>{if(data.error!==TcHmi.Errors.NONE||!data.response)return void TcHmi.Callback.callSafeEx(callback,null,{error:data.error,details:data.details});let result={},disabledUsers=data.response.commands.find(x=>x.symbol===domain+".ListDisabledUsers")?.readValue??[],listUsersCommand=data.response.commands.find(x=>"ListUsers"===x.symbol),userConfigListCommand=data.response.commands.find(x=>x.symbol==="TcHmiSrv.Config::USERGROUPUSERS::"+domain);if(listUsersV2Available){if(!listUsersCommand||listUsersCommand.error||!listUsersCommand.readValue)return void TcHmi.Callback.callSafeEx(callback,null,{error:TcHmi.Errors.E_SERVER_COMMAND_ERROR,details:{code:TcHmi.Errors.E_SERVER_COMMAND_ERROR,message:TcHmi.Errors[TcHmi.Errors.E_SERVER_COMMAND_ERROR],reason:`Error in command for symbol: "ListUsers" in response from server with id: ${data.response.id}`,domain:"TcHmi.Server",errors:listUsersCommand?.error?[listUsersCommand.error]:void 0}});for(let user of listUsersCommand.readValue)result[user.name]={domain,enabled:!disabledUsers.includes(user.name),autoLogout:user.autoLogoff,locale:user.locale,timeFormatLocale:user.timeFormatLocale,timeZone:user.timeZone,groups:user.groups}}else if(!listUsersV2Available){if(!userConfigListCommand||userConfigListCommand.error||!userConfigListCommand.readValue)return void TcHmi.Callback.callSafeEx(callback,null,{error:TcHmi.Errors.E_SERVER_COMMAND_ERROR,details:{code:TcHmi.Errors.E_SERVER_COMMAND_ERROR,message:TcHmi.Errors[TcHmi.Errors.E_SERVER_COMMAND_ERROR],reason:`Error in command for symbol: "TcHmiSrv.Config::USERGROUPUSERS::${domain}" in response from server with id: ${data.response.id}`,domain:"TcHmi.Server",errors:listUsersCommand?.error?[listUsersCommand.error]:void 0}});for(const[userName,userConfig]of Object.entries(userConfigListCommand.readValue))result[userName]={domain,enabled:!disabledUsers.includes(userName),autoLogout:userConfig.USERGROUPUSERS_AUTO_LOGOFF,locale:userConfig.USERGROUPUSERS_LOCALE,timeFormatLocale:userConfig.USERGROUPUSERS_TIMEFORMATLOCALE,timeZone:userConfig.USERGROUPUSERS_TIMEZONE,groups:userConfig.USERGROUPUSERS_GROUPS}}TcHmi.Callback.callSafeEx(callback,null,{error:TcHmi.Errors.NONE,userDetails:result})}}))){const errorDetail={code:TcHmi.Errors.ERROR,message:TcHmi.Errors[TcHmi.Errors.ERROR],reason:"Request could not be sent.",domain:"TcHmi.Server.UserManagement"};return TcHmi.Callback.callSafeEx(callback,null,{error:errorDetail.code,details:errorDetail}),errorDetail}return{code:TcHmi.Errors.NONE}}
/**
 * Lists all user groups as a dictionary with all meta data
 * @param callback Will be called after request.
 * @preserve (Part of the public API)
 */export function listUserGroups(callback=null){return listUserGroupsEx(null,null,callback)}
/**
 * Lists all user groups as a dictionary with all meta data
 * @param _options (not used till now)
 * @param requestOptions Options for the request itself
 * @param callback Will be called after request.
 * @preserve (Part of the public API)
 */export function listUserGroupsEx(_options,requestOptions=null,callback=null){if(null===Server.requestEx({requestType:"ReadWrite",commands:[{commandOptions:["SendErrorMessage"],symbol:"TcHmiSrv.Config::USERGROUPS"}]},requestOptions,Server.handleResponse({error:data=>{if(data.error===TcHmi.Errors.NONE&&data.results){let res=data.results[0];TcHmi.Callback.callSafeEx(callback,null,{error:res.error,details:res.details})}else TcHmi.Callback.callSafeEx(callback,null,{error:data.error,details:data.details})},success:data=>{let result={},groupList=data.results[0].value;for(let groupName in groupList)result[groupName]={enabled:groupList[groupName].ENABLED,fileAccess:groupList[groupName].FILEACCESS,files:groupList[groupName].FILES,symbolAccess:groupList[groupName].SYMBOLACCESS,symbols:groupList[groupName].SYMBOLS};TcHmi.Callback.callSafeEx(callback,null,{error:TcHmi.Errors.NONE,groupDetailsList:result})}}))){const errorDetail={code:TcHmi.Errors.ERROR,message:TcHmi.Errors[TcHmi.Errors.ERROR],reason:"Request could not be sent.",domain:"TcHmi.Server.UserManagement"};return TcHmi.Callback.callSafeEx(callback,null,{error:errorDetail.code,details:errorDetail}),errorDetail}return{code:TcHmi.Errors.NONE}}
/**
 * Lists all user group names as a string array.
 * @param callback Will be called after request.
 * @preserve (Part of the public API)
 */export function listUserGroupNames(callback=null){return listUserGroupNamesEx(null,null,callback)}
/**
 * Lists all user group names as a string array.
 * @param _options (not used till now)
 * @param requestOptions Options for the request itself
 * @param callback Will be called after request.
 * @preserve (Part of the public API)
 */export function listUserGroupNamesEx(_options,requestOptions=null,callback=null){if(null===Server.requestEx({requestType:"ReadWrite",commands:[{commandOptions:["SendErrorMessage"],symbol:"ListUserGroups"}]},requestOptions,Server.handleResponse({error:data=>{if(data.error===TcHmi.Errors.NONE&&data.results){let res=data.results[0];TcHmi.Callback.callSafeEx(callback,null,{error:res.error,details:res.details})}else TcHmi.Callback.callSafeEx(callback,null,{error:data.error,details:data.details})},success:data=>{TcHmi.Callback.callSafeEx(callback,null,{error:TcHmi.Errors.NONE,groupNames:data.response.commands[0].readValue})}}))){const errorDetail={code:TcHmi.Errors.ERROR,message:TcHmi.Errors[TcHmi.Errors.ERROR],reason:"Request could not be sent.",domain:"TcHmi.Server.UserManagement"};return TcHmi.Callback.callSafeEx(callback,null,{error:errorDetail.code,details:errorDetail}),errorDetail}return{code:TcHmi.Errors.NONE}}
/**
 * Lists all users of a group as a string array
 * @param groupName group name to check
 * @param callback Will be called after request.
 * @preserve (Part of the public API)
 */export function listUsersInGroup(groupName,callback=null){return listUsersInGroupEx(groupName,null,null,callback)}
/**
 * Lists all users of a group as a string array
 * @param groupName group name to check
 * @param options Options
 * @param requestOptions Options for the request itself
 * @param callback Will be called after request.
 * @preserve (Part of the public API)
 */export function listUsersInGroupEx(groupName,options,requestOptions=null,callback=null){let paramInvalid=isParameterTypeInvalid(groupName,"groupName",{type:"string",required:"valueNeeded",minStringLength:1},"TcHmi.Server.UserManagement",callback);if(paramInvalid)return paramInvalid;let domain=accessManager.getCurrentUserConfig().defaultAuthExtension;if(options){let paramInvalid=isParameterTypeInvalid(options.domain,"options.domain",{type:"string",required:"undefinedOk",minStringLength:1},"TcHmi.Server.UserManagement",callback);if(paramInvalid)return paramInvalid;"string"==typeof options.domain&&options.domain.length>0&&(domain=options.domain)}const request={requestType:"ReadWrite",commands:[{commandOptions:["SendErrorMessage"],symbol:"TcHmiSrv.Config::USERGROUPS"},{commandOptions:["SendErrorMessage"],symbol:"TcHmiSrv.Config::USERGROUPUSERS::"+domain}]};if(null===Server.requestEx(request,requestOptions,Server.handleResponse({error:data=>{if(data.error===TcHmi.Errors.NONE&&data.results){let res=data.results.find(data=>data.error!==TcHmi.Errors.NONE);TcHmi.Callback.callSafeEx(callback,null,{error:res.error,details:res.details})}else TcHmi.Callback.callSafeEx(callback,null,{error:data.error,details:data.details})},success:data=>{const groupList=data.results[0].value;if(groupName in groupList){let result=data.response.commands[1].readValue,userList=[];for(let userName in result)result[userName].USERGROUPUSERS_GROUPS&&result[userName].USERGROUPUSERS_GROUPS.includes(groupName)&&userList.push(userName);TcHmi.Callback.callSafeEx(callback,null,{error:TcHmi.Errors.NONE,userList})}else TcHmi.Callback.callSafeEx(callback,null,{error:TcHmi.Errors.E_KEY_NOT_FOUND,details:{code:TcHmi.Errors.E_KEY_NOT_FOUND,reason:"Requested user group not found",domain:"TcHmi.Server.UserManagement"}})}}))){const errorDetail={code:TcHmi.Errors.ERROR,message:TcHmi.Errors[TcHmi.Errors.ERROR],reason:"Request could not be sent.",domain:"TcHmi.Server.UserManagement"};return TcHmi.Callback.callSafeEx(callback,null,{error:errorDetail.code,details:errorDetail}),errorDetail}return{code:TcHmi.Errors.NONE}}
/**
 * Removes a user
 * @param userName user name to remove
 * @param callback Will be called after request.
 * @preserve (Part of the public API)
 */export function removeUser(userName,callback=null){return removeUserEx(userName,null,null,callback)}
/**
 * Removes a user
 * @param userName user name to remove
 * @param options Options
 * @param requestOptions Options for the request itself
 * @param callback Will be called after request.
 * @preserve (Part of the public API)
 */export function removeUserEx(userName,options,requestOptions=null,callback=null){let paramInvalid=isParameterTypeInvalid(userName,"userName",{type:"string",required:"valueNeeded",minStringLength:1},"TcHmi.Server.UserManagement",callback);if(paramInvalid)return paramInvalid;let domain=accessManager.getCurrentUserConfig().defaultAuthExtension;if(options){let paramInvalid=isParameterTypeInvalid(options.domain,"options.domain",{type:"string",required:"undefinedOk",minStringLength:1},"TcHmi.Server.UserManagement",callback);if(paramInvalid)return paramInvalid;"string"==typeof options.domain&&options.domain.length>0&&(domain=options.domain)}const request={requestType:"ReadWrite",commands:[{commandOptions:["SendErrorMessage"],symbol:"RemoveUser",writeValue:{userName,domain}}]};if(null===Server.requestEx(request,requestOptions,Server.handleResponse({error:data=>{if(data.error===TcHmi.Errors.NONE&&data.results){let res=data.results[0];TcHmi.Callback.callSafeEx(callback,null,{error:res.error,details:res.details})}else TcHmi.Callback.callSafeEx(callback,null,{error:data.error,details:data.details})},success:()=>{TcHmi.Callback.callSafeEx(callback,null,{error:TcHmi.Errors.NONE})}}))){const errorDetail={code:TcHmi.Errors.ERROR,message:TcHmi.Errors[TcHmi.Errors.ERROR],reason:"Request could not be sent.",domain:"TcHmi.Server.UserManagement"};return TcHmi.Callback.callSafeEx(callback,null,{error:errorDetail.code,details:errorDetail}),errorDetail}return{code:TcHmi.Errors.NONE}}
/**
 * Update user config
 * @param userName Username to update.
 * @param options Details for this user.
 * @param callback Will be called after request.
 * @preserve (Part of the public API)
 */export function updateUser(userName,options,callback=null){return updateUserEx(userName,options,null,callback)}
/**
 * Update user config
 * @param userName Username to update.
 * @param options Details for this user.
 * @param requestOptions Options for the request itself
 * @param callback Will be called after request.
 * @preserve (Part of the public API)
 */export function updateUserEx(userName,options,requestOptions=null,callback=null){let paramInvalid=isParameterTypeInvalid(userName,"userName",{type:"string",required:"valueNeeded",minStringLength:1},"TcHmi.Server.UserManagement",callback);if(paramInvalid)return paramInvalid;if(paramInvalid=isParameterTypeInvalid(options,"options",{type:"object",required:"valueNeeded"},"TcHmi.Server.UserManagement",callback),paramInvalid)return paramInvalid;let domain=accessManager.getCurrentUserConfig().defaultAuthExtension;if(paramInvalid=isParameterTypeInvalid(options.domain,"options.domain",{type:"string",required:"undefinedOk",minStringLength:1},"TcHmi.Server.UserManagement",callback),paramInvalid)return paramInvalid;options&&"string"==typeof options.domain&&options.domain.length>0&&(domain=options.domain);const canWrite=function(access){if(void 0===access)throw new globalThis.Error("Internal Error: This symbol access was not requested. Please adjust request.");return access===ServerACCESS.READWRITE||access===ServerACCESS.WRITE};if(null!==Server.requestEx({requestType:"ReadWrite",commands:[{commandOptions:["SendWriteValue"],symbol:"GetSymbolAccess",writeValue:"AddOrChangeUser"},{commandOptions:["SendWriteValue"],symbol:"GetSymbolAccess",writeValue:domain+".EnableUser"},{commandOptions:["SendWriteValue"],symbol:"GetSymbolAccess",writeValue:domain+".DisableUser"},{commandOptions:["SendWriteValue"],symbol:"GetSymbolAccess",writeValue:domain+".RenameUser"}]},{},data=>{if(data.error||!data.response){const errorDetail={code:TcHmi.Errors.E_SERVER_RESPONSE_ERROR,message:TcHmi.Errors[TcHmi.Errors.E_SERVER_RESPONSE_ERROR],domain:"TcHmi.Server.UserManagement",errors:data.details?[data.details]:void 0};return void TcHmi.Callback.callSafeEx(callback,null,{error:errorDetail.code,details:errorDetail})}let AddOrChangeUserAccessCommand=data.response.commands.find(value=>"AddOrChangeUser"===value.writeValue);if(canWrite(AddOrChangeUserAccessCommand.readValue)){const settings={},writeValue={domain,userName,settings},request={requestType:"ReadWrite",commands:[{commandOptions:["SendErrorMessage"],symbol:"AddOrChangeUser",writeValue}]};if(options){if(options.currentPassword&&TcHmi.Log.warn("[Source=Framework, Module=TcHmi.Server.UserManagement.updateUser] The current user has access to server symbol AddOrChangeUser thus the given current password will be ignored by the server."),isParameterTypeInvalid(options.password,"options.password",{type:"string",required:"undefinedOk"},"TcHmi.Server.UserManagement",callback))return;if("string"==typeof options.password)writeValue.parameters={password:options.password,enabled:options.enabled??void 0};else if("boolean"==typeof options.enabled){const EnOrDisableCommandName=options.enabled?"EnableUser":"DisableUser";let EnOrDisableUserAccessCommand=data.response.commands.find(value=>value.writeValue===domain+"."+EnOrDisableCommandName);if(!canWrite(EnOrDisableUserAccessCommand.readValue)){const errorDetail={code:TcHmi.Errors.E_NOT_ALLOWED,message:TcHmi.Errors[TcHmi.Errors.E_NOT_ALLOWED],reason:"Missing access rights to "+(options.enabled?"enable ":"disable ")+userName+" ("+domain+"."+EnOrDisableCommandName+")",domain:"TcHmi.Server.UserManagement"};return void TcHmi.Callback.callSafeEx(callback,null,{error:errorDetail.code,details:errorDetail})}request.commands.push({commandOptions:["SendErrorMessage"],symbol:domain+"."+EnOrDisableCommandName,writeValue:userName})}if(isParameterTypeInvalid(options.autoLogout,"options.autoLogout",{type:"string",required:"undefinedOk",minStringLength:1},"TcHmi.Server.UserManagement",callback))return;if("string"==typeof options.autoLogout&&(settings.autoLogoff=options.autoLogout),isParameterTypeInvalid(options.locale,"options.locale",{type:"string",required:"undefinedOk",minStringLength:1},"TcHmi.Server.UserManagement",callback))return;if(("string"==typeof options.locale&&options.locale.length>0||null===options.locale)&&(settings.locale=options.locale),isParameterTypeInvalid(options.timeFormatLocale,"options.timeFormatLocale",{type:"string",required:"undefinedOk",minStringLength:1},"TcHmi.Server.UserManagement",callback))return;if(("string"==typeof options.timeFormatLocale&&options.timeFormatLocale.length>0||null===options.timeFormatLocale)&&(settings.timeFormatLocale=options.timeFormatLocale),isParameterTypeInvalid(options.timeZone,"options.timeZone",{type:"string",required:"undefinedOk",minStringLength:1},"TcHmi.Server.UserManagement",callback))return;if(("string"==typeof options.timeZone&&options.timeZone.length>0||null===options.timeZone)&&(settings.timeZone=options.timeZone),isParameterTypeInvalid(options.newName,"options.newName",{type:"string",required:"fullOptional",minStringLength:1},"TcHmi.Server.UserManagement",callback))return;if(options.newName&&options.newName===userName);else if("string"==typeof options.newName&&options.newName.length>0){let RenameUserAccessCommand=data.response.commands.find(value=>value.writeValue===domain+".RenameUser");if(!canWrite(RenameUserAccessCommand.readValue)){const errorDetail={code:TcHmi.Errors.E_NOT_ALLOWED,message:TcHmi.Errors[TcHmi.Errors.E_NOT_ALLOWED],reason:"Missing access rights for renaming "+userName+" ("+domain+".RenameUser)",domain:"TcHmi.Server.UserManagement"};return void TcHmi.Callback.callSafeEx(callback,null,{error:errorDetail.code,details:errorDetail})}request.commands.push({commandOptions:["SendErrorMessage"],symbol:domain+".RenameUser",writeValue:{currentUserName:userName,newUserName:options.newName}})}writeValue.parameters&&0===Object.keys(writeValue.parameters).length&&delete writeValue.parameters,writeValue.settings&&0===Object.keys(writeValue.settings).length&&delete writeValue.settings;const rId=Server.requestEx(request,requestOptions,Server.handleResponse({error:data=>{if(data.error===TcHmi.Errors.NONE&&data.results){for(const res of data.results)if(res.error)return void TcHmi.Callback.callSafeEx(callback,null,{error:res.error,details:res.details});TcHmi.Callback.callSafeEx(callback,null,{error:TcHmi.Errors.ERROR})}else TcHmi.Callback.callSafeEx(callback,null,{error:data.error,details:data.details})},success:data=>{let AddOrChangeUserCommandResult=data.results.find(value=>"AddOrChangeUser"===value.symbol),newGroups=tchmi_clone_object(AddOrChangeUserCommandResult.value?.settings?.groups)??[];if(!isParameterTypeInvalid(options.addGroups,"options.addGroups",{type:"string",required:"undefinedOk",minStringLength:1,expectArray:!0},"TcHmi.Server.UserManagement",callback)&&(Array.isArray(options.addGroups)&&options.addGroups.forEach(newGroup=>{newGroups.includes(newGroup)||newGroups.push(newGroup)}),!isParameterTypeInvalid(options.removeGroups,"options.removeGroups",{type:"string",required:"undefinedOk",minStringLength:1,expectArray:!0},"TcHmi.Server.UserManagement",callback)))if(Array.isArray(options.removeGroups)&&options.removeGroups.forEach(deleteGroup=>{let deleteIndex=newGroups.indexOf(deleteGroup);-1!==deleteIndex&&newGroups.splice(deleteIndex,1)}),tchmi_equal(tchmi_clone_object(newGroups).sort(),tchmi_clone_object(AddOrChangeUserCommandResult.value?.settings?.groups??[]).sort()))TcHmi.Callback.callSafeEx(callback,null,{error:TcHmi.Errors.NONE});else{const request={requestType:"ReadWrite",commands:[{commandOptions:["SendErrorMessage"],symbol:"AddOrChangeUser",writeValue:{domain,userName,settings:{groups:newGroups}}}]};"string"==typeof options.newName&&options.newName.length>0&&options.newName!==userName&&(request.commands[0].writeValue.userName=options.newName),Server.requestEx(request,requestOptions,Server.handleResponse({error:data=>{if(data.error===TcHmi.Errors.NONE&&data.results){for(const res of data.results)if(res.error)return void TcHmi.Callback.callSafeEx(callback,null,{error:res.error,details:res.details});TcHmi.Callback.callSafeEx(callback,null,{error:TcHmi.Errors.ERROR})}else TcHmi.Callback.callSafeEx(callback,null,{error:data.error,details:data.details})},success:()=>{TcHmi.Callback.callSafeEx(callback,null,{error:TcHmi.Errors.NONE})}}))}}}));if(null===rId){const errorDetail={code:TcHmi.Errors.ERROR,message:TcHmi.Errors[TcHmi.Errors.ERROR],reason:"Request could not be sent.",domain:"TcHmi.Server.UserManagement"};TcHmi.Callback.callSafeEx(callback,null,{error:errorDetail.code,details:errorDetail})}}}else{if(userName!==accessManager.getCurrentUserConfig().name){const errorDetail={code:TcHmi.Errors.E_NOT_ALLOWED,message:TcHmi.Errors[TcHmi.Errors.E_NOT_ALLOWED],reason:"Missing access rights for changing user data of another user ("+domain+".AddOrChangeUser)",domain:"TcHmi.Server.UserManagement"};return void TcHmi.Callback.callSafeEx(callback,null,{error:errorDetail.code,details:errorDetail})}if(options){if(options.newName&&options.newName!==accessManager.getCurrentUserConfig().name){const errorDetail={code:TcHmi.Errors.E_NOT_ALLOWED,message:TcHmi.Errors[TcHmi.Errors.E_NOT_ALLOWED],reason:`Missing access rights for renaming ${userName} (${domain}.RenameUser)`,domain:"TcHmi.Server.UserManagement"};return void TcHmi.Callback.callSafeEx(callback,null,{error:errorDetail.code,details:errorDetail})}if(options.addGroups?.length){const errorDetail={code:TcHmi.Errors.E_NOT_ALLOWED,message:TcHmi.Errors[TcHmi.Errors.E_NOT_ALLOWED],reason:"Missing access rights for adding groups of "+userName+" ("+domain+".AddOrChangeUser)",domain:"TcHmi.Server.UserManagement"};return void TcHmi.Callback.callSafeEx(callback,null,{error:errorDetail.code,details:errorDetail})}if(options.removeGroups?.length){const errorDetail={code:TcHmi.Errors.E_NOT_ALLOWED,message:TcHmi.Errors[TcHmi.Errors.E_NOT_ALLOWED],reason:"Missing access rights for removing groups of "+userName+" ("+domain+".AddOrChangeUser)",domain:"TcHmi.Server.UserManagement"};return void TcHmi.Callback.callSafeEx(callback,null,{error:errorDetail.code,details:errorDetail})}if(!1===options.enabled){const errorDetail={code:TcHmi.Errors.E_NOT_ALLOWED,message:TcHmi.Errors[TcHmi.Errors.E_NOT_ALLOWED],reason:"Missing access rights to disable yourself",domain:"TcHmi.Server.UserManagement"};return void TcHmi.Callback.callSafeEx(callback,null,{error:errorDetail.code,details:errorDetail})}if(options.autoLogout&&autoLogoffToMilliseconds(options.autoLogout)!==accessManager.getCurrentUserConfig().autoLogOffMilliSeconds){const errorDetail={code:TcHmi.Errors.E_NOT_ALLOWED,message:TcHmi.Errors[TcHmi.Errors.E_NOT_ALLOWED],reason:"Missing access rights for changing auto logout of "+userName+" ("+domain+".AddOrChangeUser)",domain:"TcHmi.Server.UserManagement"};return void TcHmi.Callback.callSafeEx(callback,null,{error:errorDetail.code,details:errorDetail})}const writeValue={},request={requestType:"ReadWrite",commands:[{commandOptions:["SendErrorMessage"],symbol:"ChangeUserSettings",writeValue}]};if(isParameterTypeInvalid(options.locale,"options.locale",{type:"string",required:"undefinedOk",minStringLength:1},"TcHmi.Server.UserManagement",callback))return;if(("string"==typeof options.locale&&options.locale.length>0||null===options.locale)&&(writeValue.locale=options.locale),isParameterTypeInvalid(options.timeFormatLocale,"options.locale",{type:"string",required:"undefinedOk",minStringLength:1},"TcHmi.Server.UserManagement",callback))return;if(("string"==typeof options.timeFormatLocale&&options.timeFormatLocale.length>0||null===options.timeFormatLocale)&&(writeValue.timeFormatLocale=options.timeFormatLocale),isParameterTypeInvalid(options.timeZone,"options.timeZone",{type:"string",required:"undefinedOk",minStringLength:1},"TcHmi.Server.UserManagement",callback))return;if(("string"==typeof options.timeZone&&options.timeZone.length>0||null===options.timeZone)&&(writeValue.timeZone=options.timeZone),isParameterTypeInvalid(options.password,"options.password",{type:"string",required:"undefinedOk"},"TcHmi.Server.UserManagement",callback))return;if("string"==typeof options.password){if(isParameterTypeInvalid(options.currentPassword,"options.currentPassword",{type:"string",required:"valueNeeded"},"TcHmi.Server.UserManagment",callback))return;writeValue.changePassword={currentPassword:options.currentPassword,newPassword:options.password}}if(Object.keys(writeValue).length){const rId=Server.requestEx(request,requestOptions,Server.handleResponse({error:data=>{if(data.error===TcHmi.Errors.NONE&&data.results){for(const res of data.results)if(res.error)return void TcHmi.Callback.callSafeEx(callback,null,{error:res.error,details:res.details});TcHmi.Callback.callSafeEx(callback,null,{error:TcHmi.Errors.ERROR})}else TcHmi.Callback.callSafeEx(callback,null,{error:data.error,details:data.details})},success:()=>{TcHmi.Callback.callSafeEx(callback,null,{error:TcHmi.Errors.NONE})}}));if(null===rId){const errorDetail={code:TcHmi.Errors.ERROR,message:TcHmi.Errors[TcHmi.Errors.ERROR],reason:"Request could not be sent.",domain:"TcHmi.Server.UserManagement"};TcHmi.Callback.callSafeEx(callback,null,{error:errorDetail.code,details:errorDetail})}}else TcHmi.Callback.callSafeEx(callback,null,{error:TcHmi.Errors.NONE})}}}))return{code:TcHmi.Errors.NONE};{const errorDetail={code:TcHmi.Errors.ERROR,message:TcHmi.Errors[TcHmi.Errors.ERROR],reason:"Request could not be sent.",domain:"TcHmi.Server.UserManagement"};return TcHmi.Callback.callSafeEx(callback,null,{error:errorDetail.code,details:errorDetail}),errorDetail}}
/**
 * Check access rights for usermanagement functions
 * @param options Option for setting usermanagement domain
 * @param callback Will be called after request.
 * @preserve (Part of the public API)
 */export function getApiAccess(options,callback=null){let domain=accessManager.getCurrentUserConfig().defaultAuthExtension;if(options){let paramInvalid=isParameterTypeInvalid(options.domain,"options.domain",{type:"string",required:"undefinedOk",minStringLength:1},"TcHmi.Server.UserManagement",callback);if(paramInvalid)return paramInvalid;"string"==typeof options.domain&&options.domain.length>0&&(domain=options.domain)}const symbolToCheck={};symbolToCheck.AddOrChangeUser=ServerACCESS.NONE,symbolToCheck.ListUserNames=ServerACCESS.NONE,symbolToCheck.ListUsers=ServerACCESS.NONE,symbolToCheck.ListUserGroups=ServerACCESS.NONE,symbolToCheck.RemoveUser=ServerACCESS.NONE,symbolToCheck.ChangeUserSettings=ServerACCESS.NONE,symbolToCheck["TcHmiSrv.Config"]=ServerACCESS.NONE,symbolToCheck[domain+".EnableUser"]=ServerACCESS.NONE,symbolToCheck[domain+".DisableUser"]=ServerACCESS.NONE,symbolToCheck[domain+".RenameUser"]=ServerACCESS.NONE,symbolToCheck[domain+".AddUser"]=ServerACCESS.NONE,symbolToCheck[domain+".RemoveUser"]=ServerACCESS.NONE,symbolToCheck[domain+".ChangePassword"]=ServerACCESS.NONE;let commands=[];for(let symbolName of Object.keys(symbolToCheck))commands.push({commandOptions:["SendWriteValue","SendErrorMessage"],symbol:"GetSymbolAccess",writeValue:symbolName});commands.push({commandOptions:["SendErrorMessage"],symbol:"TcHmiSrv.Config::USERGROUPUSERS::"+domain});if(null!==Server.requestEx({requestType:"ReadWrite",commands},{},data=>{if(data.error||!data.response?.commands){const errorDetail={code:TcHmi.Errors.E_SERVER_RESPONSE_ERROR,message:TcHmi.Errors[TcHmi.Errors.E_SERVER_RESPONSE_ERROR],domain:"TcHmi.Server.UserManagement",errors:data.details?[data.details]:void 0};return void TcHmi.Callback.callSafeEx(callback,null,{error:errorDetail.code,details:errorDetail})}for(let symbolName of Object.keys(symbolToCheck))symbolToCheck[symbolName]=data.response.commands.find(value=>value.writeValue===symbolName).readValue;let usergroupUsers=null!==data.response.commands.find(command=>command.symbol==="TcHmiSrv.Config::USERGROUPUSERS::"+domain)?.readValue;const canRead=function(access){if(void 0===access)throw new globalThis.Error("Internal Error: This symbol access was not requested. Please adjust request.");return access===ServerACCESS.READWRITE||access===ServerACCESS.READ},canWrite=function(access){if(void 0===access)throw new globalThis.Error("Internal Error: This symbol access was not requested. Please adjust request.");return access===ServerACCESS.READWRITE||access===ServerACCESS.WRITE},listUsersV2Available=Data.Caches.serverSymbolMetaDataCache.get("ListUsers")?.ListSymbols?.VERSIONS?.includes(2);TcHmi.Callback.callSafeEx(callback,null,{error:TcHmi.Errors.NONE,result:{addUser:{general:null!==symbolToCheck[domain+".AddUser"]&&canWrite(symbolToCheck.AddOrChangeUser),enable:null!==symbolToCheck[domain+".AddUser"]&&canWrite(symbolToCheck.AddOrChangeUser),locale:null!==symbolToCheck[domain+".AddUser"]&&canWrite(symbolToCheck.AddOrChangeUser),timeFormatLocale:null!==symbolToCheck[domain+".AddUser"]&&canWrite(symbolToCheck.AddOrChangeUser),timeZone:null!==symbolToCheck[domain+".AddUser"]&&canWrite(symbolToCheck.AddOrChangeUser),autoLogoff:null!==symbolToCheck[domain+".AddUser"]&&canWrite(symbolToCheck.AddOrChangeUser),groups:null!==symbolToCheck[domain+".AddUser"]&&canWrite(symbolToCheck.AddOrChangeUser)},listUserNames:{general:canRead(symbolToCheck.ListUserNames)},listUsers:{general:listUsersV2Available?canRead(symbolToCheck.ListUsers):usergroupUsers&&canRead(symbolToCheck["TcHmiSrv.Config"]),enabled:listUsersV2Available?canRead(symbolToCheck.ListUsers):usergroupUsers&&canRead(symbolToCheck["TcHmiSrv.Config"]),locale:listUsersV2Available?canRead(symbolToCheck.ListUsers):usergroupUsers&&canRead(symbolToCheck["TcHmiSrv.Config"]),timeFormatLocale:listUsersV2Available?canRead(symbolToCheck.ListUsers):usergroupUsers&&canRead(symbolToCheck["TcHmiSrv.Config"]),timeZone:listUsersV2Available?canRead(symbolToCheck.ListUsers):usergroupUsers&&canRead(symbolToCheck["TcHmiSrv.Config"]),autoLogoff:listUsersV2Available?canRead(symbolToCheck.ListUsers):usergroupUsers&&canRead(symbolToCheck["TcHmiSrv.Config"]),groups:listUsersV2Available?canRead(symbolToCheck.ListUsers):usergroupUsers&&canRead(symbolToCheck["TcHmiSrv.Config"])},listUserGroupNames:{general:canRead(symbolToCheck.ListUserGroups)},listUserGroups:{general:canRead(symbolToCheck["TcHmiSrv.Config"]),enabled:canRead(symbolToCheck["TcHmiSrv.Config"]),fileAccess:canRead(symbolToCheck["TcHmiSrv.Config"]),files:canRead(symbolToCheck["TcHmiSrv.Config"]),symbolAccess:canRead(symbolToCheck["TcHmiSrv.Config"]),symbols:canRead(symbolToCheck["TcHmiSrv.Config"])},listUsersInGroup:{general:usergroupUsers&&canRead(symbolToCheck["TcHmiSrv.Config"])},removeUser:{general:null!==symbolToCheck[domain+".RemoveUser"]&&canWrite(symbolToCheck.RemoveUser)},updateUser:{general:canWrite(symbolToCheck.ChangeUserSettings)||canWrite(symbolToCheck.AddOrChangeUser),newName:canWrite(symbolToCheck.AddOrChangeUser)&&canWrite(symbolToCheck[domain+".RenameUser"]),addGroups:canWrite(symbolToCheck.AddOrChangeUser),removeGroups:canWrite(symbolToCheck.AddOrChangeUser),enabled:canWrite(symbolToCheck.AddOrChangeUser)&&canWrite(symbolToCheck[domain+".EnableUser"])&&canWrite(symbolToCheck[domain+".DisableUser"]),autoLogout:canWrite(symbolToCheck.AddOrChangeUser),locale:canWrite(symbolToCheck.ChangeUserSettings)||canWrite(symbolToCheck.AddOrChangeUser),timeFormatLocale:canWrite(symbolToCheck.ChangeUserSettings)||canWrite(symbolToCheck.AddOrChangeUser),timeZone:canWrite(symbolToCheck.ChangeUserSettings)||canWrite(symbolToCheck.AddOrChangeUser),changeOwnPassword:null!==symbolToCheck[domain+".ChangePassword"]&&(canWrite(symbolToCheck.ChangeUserSettings)||canWrite(symbolToCheck.AddOrChangeUser)),changePassword:null!==symbolToCheck[domain+".AddUser"]&&canWrite(symbolToCheck.AddOrChangeUser)}}})}))return{code:TcHmi.Errors.NONE};{const errorDetail={code:TcHmi.Errors.ERROR,message:TcHmi.Errors[TcHmi.Errors.ERROR],reason:"Request could not be sent.",domain:"TcHmi.Server.UserManagement"};return TcHmi.Callback.callSafeEx(callback,null,{error:errorDetail.code,details:errorDetail}),errorDetail}}TcHmi.Server??={},TcHmi.Server.UserManagement={addUser,addUserEx,listUsernames,listUsernamesEx,listUsers,listUsersEx,listUserGroups,listUserGroupsEx,listUserGroupNames,listUserGroupNamesEx,listUsersInGroup,listUsersInGroupEx,removeUser,removeUserEx,updateUser,updateUserEx,getApiAccess};