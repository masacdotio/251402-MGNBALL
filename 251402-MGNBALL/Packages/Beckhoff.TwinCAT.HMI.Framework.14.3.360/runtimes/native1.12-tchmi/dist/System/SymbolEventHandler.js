import{isSymbolExpression}from"../API/Symbol.js";import{Symbol as SystemSymbol}from"./Symbol.js";import{SymbolExpressionFromText}from"./SymbolExpressionFromText.js";import{EventProvider}from"../API/EventProvider.js";import{Log}from"../API/Log.js";export function init(){EventProvider.register("System.EventProvider.onRegisterCallback",__handleRegister),EventProvider.register("System.EventProvider.onDestroyedCallback",__handleDestroy)}export const __destroyFnOfEntry=new Map;function __handleRegister(_event,entry){const name=entry.name,callback=entry.callback,options=entry.options,registrationData=entry.registrationData;let destroyWatch,destroyed=!1,destroyNeeded=!1,s=null;const nameExpressionSymbols=[],nameValueSymbols=[],destroyNameValueWatches=()=>{for(const item of nameValueSymbols)item.destroyWatch(),item.symbol.destroy();nameValueSymbols.splice(0,nameValueSymbols.length)};let registeredName="";const destroyEvent=()=>{registeredName&&(destroyWatch&&(destroyWatch(),destroyWatch=void 0),s&&(s.destroy(),s=null),subEventDestroy?.(),subEventDestroy=null,registeredName="")};let subEventDestroy=null;const destroy=()=>{destroyed=!0,(()=>{for(const item of nameExpressionSymbols)item.destroyWatch(),item.symbol.destroy();nameExpressionSymbols.splice(0,nameExpressionSymbols.length)})(),destroyNameValueWatches(),destroyEvent()},register=name=>{registeredName=name,name!==entry.name&&(destroyNeeded=!0,subEventDestroy=EventProvider.register(name,callback,options,registrationData)),isSymbolExpression(name)&&(destroyNeeded=!0,s=new SystemSymbol({expression:name,ctx:registrationData?.ctx}),destroyWatch=s.watch(function(data){destroyWatch||(destroyWatch=data.destroy),data.error===TcHmi.Errors.NONE&&TcHmi.Callback.callSafeEx(callback,null,{name,destroy},data.value)}))},handleSymbols=symbolExpressions=>{const symbolExpressionsToResolve=new Map(symbolExpressions.filter(expression=>"Resolve"===expression.options.EventRegistrationMode).filter((a,_index,expressions)=>!expressions.some(b=>b.original.toString()!==a.original.toString()&&b.original.toString().includes(a.original.toString()))).map(expression=>[expression.original,{isResolved:!1}]));if(0===symbolExpressionsToResolve.size)return void register(name);const nameParts=[],toWatch=[];let position=0;for(const[expression,state]of symbolExpressionsToResolve){const splitIndex=name.indexOf(expression.toString(),position);if(-1===splitIndex)continue;splitIndex!==position&&nameParts.push(name.substring(position,splitIndex));const index=nameParts.length;nameParts.push(""),position+=splitIndex+expression.toString().length,toWatch.push({expression,state,index})}position<name.length&&nameParts.push(name.substring(position));for(const item of toWatch){const symbol=new SystemSymbol({expression:item.expression,ctx:registrationData?.ctx}),destroyWatch=symbol.watch(data=>{data.error===TcHmi.Errors.NONE&&"value"in data?(item.state.isResolved=!0,nameParts[item.index]=data.value,Array.from(symbolExpressionsToResolve.values()).every(state=>state.isResolved)&&!destroyed&&(destroyEvent(),register(nameParts.join("")))):Log.error(`[Source=Framework, Module=TcHmi.EventProvider] Failed to watch symbol '${item.expression.toString()}': ${TcHmi.Log.buildMessage(data.details)}`)});nameValueSymbols.push({symbol,destroyWatch}),destroyNeeded=!0}},symbolExpressions=new SymbolExpressionFromText(name).resolveExpressions().map(expression=>({original:expression,resolved:expression.hasChildren()?null:expression}));if(0===symbolExpressions.length)register(name);else{const symbolExpressionsToWatch=symbolExpressions.filter(expression=>!expression.resolved).filter((a,_index,expressions)=>!expressions.some(b=>b.original.toString()!==a.original.toString()&&b.original.toString().includes(a.original.toString())));if(0===symbolExpressionsToWatch.length)handleSymbols(symbolExpressions.map(expression=>({original:expression.original,options:expression.resolved.getOptions()})));else for(const expression of symbolExpressionsToWatch){const symbol=new SystemSymbol({expression:expression.original,ctx:registrationData?.ctx}),destroyWatch=symbol.watchExpression(data=>{if(data.error!==TcHmi.Errors.NONE||!data.value)return void Log.error(`[Source=Framework, Module=TcHmi.EventProvider] Failed to watch expression '${expression.original.toString()}': ${TcHmi.Log.buildMessage(data.details)}`);const changed=!expression.resolved||expression.resolved.getOptions().EventRegistrationMode!==data.value.getOptions().EventRegistrationMode;expression.resolved=data.value,symbolExpressions.every(expression=>null!==expression.resolved)&&changed&&!destroyed&&(destroyNameValueWatches(),destroyEvent(),handleSymbols(symbolExpressions.map(expression=>({original:expression.original,options:expression.resolved.getOptions()}))))});nameExpressionSymbols.push({symbol,destroyWatch}),destroyNeeded=!0}}destroyNeeded&&__destroyFnOfEntry.set(entry,destroy)}function __handleDestroy(_event,entry){const destroy=__destroyFnOfEntry.get(entry);destroy&&(destroy(),__destroyFnOfEntry.delete(entry))}