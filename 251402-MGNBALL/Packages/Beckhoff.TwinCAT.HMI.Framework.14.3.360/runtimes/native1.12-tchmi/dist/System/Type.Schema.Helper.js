import{controlManager}from"./ControlManager.js";import{SharedCacheRaw,SharedCacheResolved}from"./Type.TypeManager.js";import{getSchema}from"../API/Type.js";export function __resolveRefIdParts(id){if(id.startsWith("tchmi:")){let sharpIndex=id.indexOf("#");if(-1===sharpIndex)return{error:TcHmi.Errors.E_SCHEMA_INVALID_REF_ID,details:{code:TcHmi.Errors.E_SCHEMA_INVALID_REF_ID,message:TcHmi.Errors[TcHmi.Errors.E_SCHEMA_INVALID_REF_ID],reason:'Reference id: "'+id+'" is not valid. Missing "#".',domain:"TcHmi.System.Type.TypeManager"}};let source=id.substr(6,sharpIndex-6);if(!source)return{error:TcHmi.Errors.E_SCHEMA_INVALID_REF_ID,details:{code:TcHmi.Errors.E_SCHEMA_INVALID_REF_ID,message:TcHmi.Errors[TcHmi.Errors.E_SCHEMA_INVALID_REF_ID],reason:'Reference id: "'+id+'" is not valid. Missing name of schema source between "tchmi:" and "#".',domain:"TcHmi.System.Type.TypeManager"}};let path=id.substr(sharpIndex+2,id.length-sharpIndex+2),pathTokens=path.split("/");return{error:TcHmi.Errors.NONE,parts:{isRelative:!1,source,path,pathTokens}}}if(id.startsWith("#")){let sharpIndex=id.indexOf("#");if(-1===sharpIndex)return{error:TcHmi.Errors.E_SCHEMA_INVALID_REF_ID,details:{code:TcHmi.Errors.E_SCHEMA_INVALID_REF_ID,message:TcHmi.Errors[TcHmi.Errors.E_SCHEMA_INVALID_REF_ID],reason:'Reference id: "'+id+'" is not valid. Missing "#".',domain:"TcHmi.System.Type.TypeManager"}};let path=id.substr(sharpIndex+2,id.length-sharpIndex+2),pathTokens=path.split("/");return{error:TcHmi.Errors.NONE,parts:{isRelative:!0,path,pathTokens}}}return{error:TcHmi.Errors.E_SCHEMA_INVALID_REF_ID,details:{code:TcHmi.Errors.E_SCHEMA_INVALID_REF_ID,message:TcHmi.Errors[TcHmi.Errors.E_SCHEMA_INVALID_REF_ID],reason:'Reference id: "'+id+'" is not valid.',domain:"TcHmi.System.Type.TypeManager"}}}export function __resolveRawSchemaDefinitionPart(partSchema,sourceOrRootSchema,path,$refPath){let source,rootSchema;"string"==typeof sourceOrRootSchema?source=sourceOrRootSchema:"object"==typeof sourceOrRootSchema&&(rootSchema=sourceOrRootSchema),source?$refPath.set("tchmi:"+source+"#"+path,null):$refPath.set("#"+path,null);for(const[key,prop]of Object.entries(partSchema)){if("$ref"===key&&"string"==typeof prop){let resolvedSchema,bAbort=!1;if($refPath.has(prop))bAbort=!0;else if(prop.startsWith("#")){let propPathSanitized;propPathSanitized=source?"tchmi:"+source+prop:prop,$refPath.has(propPathSanitized)&&(bAbort=!0)}if(bAbort)return resolvedSchema=partSchema,{error:TcHmi.Errors.NONE,part:resolvedSchema};let newBaseId=null;const propURIDecoded=decodeURIComponent(prop);if(SharedCacheResolved.has(prop)?(resolvedSchema=SharedCacheResolved.get(prop),newBaseId=prop):SharedCacheResolved.has(propURIDecoded)&&(resolvedSchema=SharedCacheResolved.get(propURIDecoded),newBaseId=propURIDecoded),!resolvedSchema){let $refPathNew=new Map;$refPath.forEach((value,key)=>{$refPathNew.set(key,value)});let res=__resolveRawSchemaDefinition(prop,source||rootSchema,$refPathNew);if(res&&res.error===TcHmi.Errors.NONE)newBaseId=prop,resolvedSchema=res.schema;else{let resDecoded=__resolveRawSchemaDefinition(propURIDecoded,source,$refPathNew);if(!resDecoded||resDecoded.error!==TcHmi.Errors.NONE)return resDecoded;newBaseId=propURIDecoded,resolvedSchema=resDecoded.schema}}let clone=tchmi_clone_object(resolvedSchema),newIdPartsRes=__resolveRefIdParts(newBaseId);if(newIdPartsRes.error!==TcHmi.Errors.NONE)return{error:newIdPartsRes.error,details:newIdPartsRes.details};let idURIEncoded,newIdParts=newIdPartsRes.parts;idURIEncoded=newIdParts.source?"tchmi:"+newIdParts.source+"#":"#";for(let token of newIdParts.pathTokens)idURIEncoded+="/"+encodeURIComponent(token);return clone.id=idURIEncoded,clone.base&&delete clone.base,{error:TcHmi.Errors.NONE,part:clone}}if("allOf"===key&&Array.isArray(prop)){let resolvedSchema={};const merge=(o1,o2)=>{let keys=Object.keys(o2);for(let i=0,ii=keys.length;i<ii;i++){let key=keys[i];o1[key]&&"object"==typeof o1[key]?merge(o1[key],o2[key]):o1[key]=o2[key]}};for(let i=0,ii=prop.length;i<ii;i++){let entry=prop[i],$refPathNew=new Map;$refPath.forEach((value,key)=>{$refPathNew.set(key,value)});let newPath=path+"/allOf/"+i;source?$refPathNew.set("tchmi:"+source+"#"+path,null):$refPathNew.set("#"+path,null);let res=__resolveRawSchemaDefinitionPart(entry,source||rootSchema,newPath,$refPathNew);if(res.error!==TcHmi.Errors.NONE||!res.part)return res;res.part.id&&(resolvedSchema.base?resolvedSchema.base&&Array.isArray(resolvedSchema.base)?resolvedSchema.base.push(res.part.id):resolvedSchema.base&&!Array.isArray(resolvedSchema.base)&&(resolvedSchema.base=[resolvedSchema.base,res.part.id]):resolvedSchema.base=res.part.id),merge(resolvedSchema,res.part)}return delete resolvedSchema.id,{error:TcHmi.Errors.NONE,part:resolvedSchema}}if(null!==prop&&"object"==typeof prop){let $refPathNew=new Map;$refPath.forEach((value,key)=>{$refPathNew.set(key,value)});let newPath=path+"/"+key;source?$refPathNew.set("tchmi:"+source+"#"+path,null):$refPathNew.set("#"+path,null);let res=__resolveRawSchemaDefinitionPart(prop,source||rootSchema,newPath,$refPathNew);if(res.error!==TcHmi.Errors.NONE)return res;partSchema[key]=res.part}}return{error:TcHmi.Errors.NONE,part:partSchema}}export function __resolveRawSchemaDefinition(id,sourceOrDefinitionsSchema,$refPath){let schema=SharedCacheResolved.get(id);if(schema)return{error:TcHmi.Errors.NONE,schema};if(schema=SharedCacheResolved.get(encodeURI(id)),schema)return{error:TcHmi.Errors.NONE,schema};let res=__resolveRefIdParts(id);if(res.error!==TcHmi.Errors.NONE)return{error:res.error,details:res.details};let parts=res.parts;if(parts.isRelative){if(parts.isRelative&&sourceOrDefinitionsSchema){let definitions;if("string"==typeof sourceOrDefinitionsSchema?definitions=SharedCacheRaw.get(sourceOrDefinitionsSchema):"object"==typeof sourceOrDefinitionsSchema&&(definitions=sourceOrDefinitionsSchema),!definitions)return{error:TcHmi.Errors.E_SCHEMA_UNKNOWN_SOURCE,details:{code:TcHmi.Errors.E_SCHEMA_UNKNOWN_SOURCE,message:TcHmi.Errors[TcHmi.Errors.E_SCHEMA_UNKNOWN_SOURCE],reason:"Can not find definitions targeted within ref: "+id,domain:"TcHmi.System.Type.TypeManager"}};let rawSchemaByPath=definitions;for(let i=0;i<parts.pathTokens.length&&rawSchemaByPath;i++){rawSchemaByPath=rawSchemaByPath[parts.pathTokens[i]]}if(!rawSchemaByPath)return{error:TcHmi.Errors.E_SCHEMA_UNKNOWN_DEFINITION,details:{code:TcHmi.Errors.E_SCHEMA_UNKNOWN_DEFINITION,message:TcHmi.Errors[TcHmi.Errors.E_SCHEMA_UNKNOWN_DEFINITION],reason:"string"==typeof sourceOrDefinitionsSchema?'Can not find definition for path: "'+parts.path+'" in source: "'+sourceOrDefinitionsSchema+'" targeted within ref: '+id:'Can not find definition for path: "'+parts.path+'" targeted within ref: '+id,domain:"TcHmi.System.Type.TypeManager"}};let newIdPartsRes=__resolveRefIdParts(id);if(newIdPartsRes.error!==TcHmi.Errors.NONE)return{error:newIdPartsRes.error,details:newIdPartsRes.details};let newIdURIEncoded,newIdParts=newIdPartsRes.parts;newIdURIEncoded=parts.source?"tchmi:"+parts.source+"#":"#";for(let token of newIdParts.pathTokens)newIdURIEncoded+="/"+encodeURIComponent(token);let rawSchemaByPathClone=tchmi_clone_object(rawSchemaByPath);rawSchemaByPathClone.id=newIdURIEncoded,rawSchemaByPathClone.base&&delete rawSchemaByPathClone.base;let $refPathNew=new Map;$refPath.forEach((value,key)=>{$refPathNew.set(key,value)}),$refPathNew.set(id,null);let resolvePartResult=__resolveRawSchemaDefinitionPart(rawSchemaByPathClone,parts.source,"/"+parts.path,$refPathNew);if(resolvePartResult.error!==TcHmi.Errors.NONE){let res={error:TcHmi.Errors.E_SCHEMA_NOT_RESOLVED,details:{code:TcHmi.Errors.E_SCHEMA_NOT_RESOLVED,message:TcHmi.Errors[TcHmi.Errors.E_SCHEMA_NOT_RESOLVED],reason:'Failed to resolve schema for path: "'+parts.path+'" in source: "'+parts.source+'" like targeted within ref: '+id,domain:"TcHmi.System.Type.TypeManager"}};return resolvePartResult.details&&res.details&&(res.details.errors=[resolvePartResult.details]),res}return resolvePartResult.part?{error:TcHmi.Errors.NONE,schema:resolvePartResult.part}:resolvePartResult}return{error:TcHmi.Errors.E_SCHEMA_INVALID_REF_ID,details:{code:TcHmi.Errors.E_SCHEMA_INVALID_REF_ID,message:TcHmi.Errors[TcHmi.Errors.E_SCHEMA_INVALID_REF_ID],reason:'Reference id: "'+id+'" is not valid.',domain:"TcHmi.System.Type.TypeManager"}}}{if(!parts.source)return{error:TcHmi.Errors.E_SCHEMA_INVALID_REF_ID,details:{code:TcHmi.Errors.E_SCHEMA_INVALID_REF_ID,message:TcHmi.Errors[TcHmi.Errors.E_SCHEMA_INVALID_REF_ID],reason:'Reference id: "'+id+'" is not valid. Missing name of source between "tchmi:" and "#".',domain:"TcHmi.System.Type.TypeManager"}};let source=SharedCacheRaw.get(parts.source);if(!source)return{error:TcHmi.Errors.E_SCHEMA_UNKNOWN_SOURCE,details:{code:TcHmi.Errors.E_SCHEMA_UNKNOWN_SOURCE,message:TcHmi.Errors[TcHmi.Errors.E_SCHEMA_UNKNOWN_SOURCE],reason:'Can not find source: "'+parts.source+'" like targeted within ref: '+id,domain:"TcHmi.System.Type.TypeManager"}};let rawSchemaByPath=source;for(let i=0;i<parts.pathTokens.length&&rawSchemaByPath;i++){let pathToken=parts.pathTokens[i],temp=rawSchemaByPath[pathToken];if(!temp){let pathTokenDecoded=decodeURIComponent(pathToken);temp=rawSchemaByPath[pathTokenDecoded],temp&&(parts.pathTokens[i]=pathTokenDecoded)}rawSchemaByPath=temp}if(!rawSchemaByPath)return{error:TcHmi.Errors.E_SCHEMA_UNKNOWN_DEFINITION,details:{code:TcHmi.Errors.E_SCHEMA_UNKNOWN_DEFINITION,message:TcHmi.Errors[TcHmi.Errors.E_SCHEMA_UNKNOWN_DEFINITION],reason:'Can not find definition for path: "'+parts.path+'" in source: "'+parts.source+'" like targeted within ref: '+id,domain:"TcHmi.System.Type.TypeManager"}};let rawSchemaByPathClone=tchmi_clone_object(rawSchemaByPath),$refPathNew=new Map;$refPath.forEach((value,key)=>{$refPathNew.set(key,value)}),$refPathNew.set(id,null);let newIdURIEncoded,resolvePartResult=__resolveRawSchemaDefinitionPart(rawSchemaByPathClone,parts.source,"/"+parts.path,$refPathNew);if(resolvePartResult.error!==TcHmi.Errors.NONE){let res={error:TcHmi.Errors.E_SCHEMA_NOT_RESOLVED,details:{code:TcHmi.Errors.E_SCHEMA_NOT_RESOLVED,message:TcHmi.Errors[TcHmi.Errors.E_SCHEMA_NOT_RESOLVED],reason:'Failed to resolve schema for path: "'+parts.path+'" in source: "'+parts.source+'" like targeted within ref: '+id,domain:"TcHmi.System.Type.TypeManager"}};return resolvePartResult.details&&res.details&&(res.details.errors=[resolvePartResult.details]),res}if(!resolvePartResult.part)return resolvePartResult;newIdURIEncoded=parts.source?"tchmi:"+parts.source+"#":"#";for(let token of parts.pathTokens)newIdURIEncoded+="/"+encodeURIComponent(token);return resolvePartResult.part.id=newIdURIEncoded,resolvePartResult.part.base&&delete resolvePartResult.part.base,SharedCacheResolved.set(id,resolvePartResult.part),{error:TcHmi.Errors.NONE,schema:resolvePartResult.part}}}export function __resolveRawSchema(schema,source,$refPath,version){let schemaClone=tchmi_clone_object(schema),$refPathNew=new Map;$refPath.forEach((value,key)=>{$refPathNew.set(key,value)});let resolvePartResult=__resolveRawSchemaDefinitionPart(schemaClone,source||schema,"",$refPathNew);if(resolvePartResult.error!==TcHmi.Errors.NONE)return resolvePartResult;if(!resolvePartResult.part)return resolvePartResult;source&&resolvePartResult.part&&resolvePartResult.part.id&&!resolvePartResult.part.id.includes("tchmi:")&&(resolvePartResult.part.id="tchmi:"+source+resolvePartResult.part.id);let res=resolvePartResult.part;if(version){let schemaOf=res.oneOf;if(schemaOf||(schemaOf=res.anyOf),schemaOf)for(let schema of schemaOf)if(schema.versions&&schema.versions.includes(version)){res=schema;break}}return{error:TcHmi.Errors.NONE,schema:res}}export function __resolveSubSchema(schema,pathTokens,callback){let res=schema,pathDone="";if(!pathTokens||0===pathTokens.length)return void TcHmi.Callback.callSafeEx(callback,null,{error:TcHmi.Errors.NONE,schema:res});if(null==res||"object"!=typeof res)return void TcHmi.Callback.callSafeEx(callback,null,{error:TcHmi.Errors.E_SCHEMA_INVALID,details:{code:TcHmi.Errors.E_SCHEMA_INVALID,message:TcHmi.Errors[TcHmi.Errors.E_SCHEMA_INVALID],reason:"Failed to read schema because there is no valid schema below this path.",domain:"TcHmi.System.Type.Schema.Helper"}});let pTokens=tchmi_clone_object(pathTokens);for(;pTokens.length>0;){let schemaOf=null;if(res&&res.anyOf?schemaOf=res.anyOf:res&&res.oneOf&&(schemaOf=res.oneOf),schemaOf){let bHit=!1;for(let schema of schemaOf)if(__resolveSubSchema(schema,pTokens,data=>{data.error===TcHmi.Errors.NONE&&data.schema&&(res=data.schema,bHit=!0)}),bHit&&res)return void TcHmi.Callback.callSafeEx(callback,null,{error:TcHmi.Errors.NONE,schema:res});if(!bHit)return void TcHmi.Callback.callSafeEx(callback,null,{error:TcHmi.Errors.E_SCHEMA_INVALID_PATH,details:{code:TcHmi.Errors.E_SCHEMA_INVALID_PATH,message:TcHmi.Errors[TcHmi.Errors.E_SCHEMA_INVALID_PATH],reason:'Failed to read schema by path because path: "'+new TcHmi.ObjectPath(pTokens).toString()+'" can not be resolved from any anyOf/oneOf schema below path: "'+pathDone+'" in schema with id: '+schema.id,domain:"TcHmi.System.Type.Schema.Helper"}})}let pToken=pTokens.shift();if(res&&"TcHmi.Controls.System.TcHmiControl"===res.frameworkInstanceOf)if(res.frameworkUserControlConfig){let attr=controlManager.getUserControlConfigAttributeByPropertyName(res.frameworkUserControlConfig,pToken);if(!attr){res=null;break}if(res=getSchema(attr.type),0===pTokens.length)break}else{let attr=controlManager.getDescriptionAttributeByPropertyName(res.frameworkControlType,pToken);if(!attr){res=null;break}if(res=getSchema(attr.type),0===pTokens.length)break}if(res&&"TcHmi.Controls.System.TcHmiControl"===res.frameworkInstanceOf)continue;let pTokenTokens=[],chars=pToken.split(""),idx=0;for(;chars.length>0;){let c=chars.shift();"["===c&&void 0!==pTokenTokens[idx]&&pTokenTokens[idx].length>0&&idx++,void 0===pTokenTokens[idx]&&(pTokenTokens[idx]=""),pTokenTokens[idx]=pTokenTokens[idx]+c,"]"===c&&idx++}let bHit=!1;for(;pTokenTokens.length>0;){let pTokenToken=pTokenTokens.shift();if(pTokenToken.match(/\[*.\]/g)){if(res&&void 0!==res.items&&"object"==typeof res.items&&!Array.isArray(res.items)){res=res.items,bHit=!0,pathDone+="["+pToken+"]";continue}}else if(res&&void 0!==res.properties&&"object"==typeof res.properties&&!Array.isArray(res.properties)){if(void 0!==res.properties[pTokenToken]){res=res.properties[pTokenToken],bHit=!0,pathDone+="::"+pToken;continue}}else{if(res&&!0===res.additionalProperties&&!res.patternProperties){res=getSchema("tchmi:general#/definitions/Any"),bHit=!0,pathDone+="::"+pToken;continue}if(res&&res.patternProperties&&"object"==typeof res.patternProperties&&!Array.isArray(res.patternProperties))for(let pattern in res.patternProperties)if(pToken.match(pattern)){let patternSchema=res.patternProperties[pattern];if(patternSchema&&"object"==typeof patternSchema){res=patternSchema,bHit=!0,pathDone+="::"+pToken;continue}}if(res&&"object"==typeof res.additionalProperties&&!Array.isArray(res.additionalProperties)){res=res.additionalProperties,bHit=!0,pathDone+="::"+pToken;continue}}}if(!bHit)return void TcHmi.Callback.callSafeEx(callback,null,{error:TcHmi.Errors.E_SCHEMA_INVALID_PATH,details:{code:TcHmi.Errors.E_SCHEMA_INVALID_PATH,message:TcHmi.Errors[TcHmi.Errors.E_SCHEMA_INVALID_PATH],reason:'Failed to read schema by path because token: "'+pToken+'" does not exist below path: "'+pathDone+'" in schema with id: '+schema.id,domain:"TcHmi.System.Type.Schema.Helper"}});if(res&&res.$ref){let ref=getSchema(res.$ref);ref&&(res=ref)}}null!=res&&"object"==typeof res?TcHmi.Callback.callSafeEx(callback,null,{error:TcHmi.Errors.NONE,schema:res}):TcHmi.Callback.callSafeEx(callback,null,{error:TcHmi.Errors.E_SCHEMA_INVALID,details:{code:TcHmi.Errors.E_SCHEMA_INVALID,message:TcHmi.Errors[TcHmi.Errors.E_SCHEMA_INVALID],reason:'Failed to read schema by path because there is no valid schema below path: "'+pathDone+'" in schema with id: '+schema.id,domain:"TcHmi.System.Type.Schema.Helper"}})}