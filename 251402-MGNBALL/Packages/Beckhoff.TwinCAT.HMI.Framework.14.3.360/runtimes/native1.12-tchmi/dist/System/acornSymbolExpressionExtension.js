let nestingDepth=0,tt=acorn.tokTypes,tc=acorn.tokContexts;tc.symbolExpressionOpenTag=new acorn.TokContext("%tag",!1),tc.symbolExpressionCloseTag=new acorn.TokContext("%/tag",!1),tc.symbolExpressionExpression=new acorn.TokContext("%tag%...%/tag%",!0,!0),tt.symbolExpressionTagName=new acorn.TokenType("symbolExpressionTagName"),tt.symbolExpressionSymbolContent=new acorn.TokenType("symbolExpressionSymbolContent",{beforeExpr:!0}),tt.symbolExpressionOpenTagStart=new acorn.TokenType("symbolExpressionOpenTagStart"),tt.symbolExpressionOpenTagEnd=new acorn.TokenType("symbolExpressionOpenTagEnd"),tt.symbolExpressionCloseTagStart=new acorn.TokenType("symbolExpressionCloseTagStart"),tt.symbolExpressionCloseTagEnd=new acorn.TokenType("symbolExpressionCloseTagEnd"),tt.symbolExpressionOpenTagStart.updateContext=function(){this.context.push(tc.symbolExpressionExpression),this.context.push(tc.symbolExpressionOpenTag),this.exprAllowed=!1},tt.symbolExpressionOpenTagEnd.updateContext=function(prevType){this.context.pop(),this.exprAllowed=!0},tt.symbolExpressionCloseTagStart.updateContext=function(){this.context.pop(),this.context.push(tc.symbolExpressionCloseTag),this.exprAllowed=!1},tt.symbolExpressionCloseTagEnd.updateContext=function(prevType){this.context.pop(),this.exprAllowed=!1};let pp=acorn.Parser.prototype;pp.symbolExpression_readToken=function(){let out="";const chunkStart=this.pos;for(;;){this.pos>=this.input.length&&(nestingDepth=0,this.raise(this.start,"Unterminated TcHmi Symbol Extension contents"));let ch=this.input.charCodeAt(this.pos);if(37===ch)return this.pos===this.start?this.getTokenFromCode(ch):(out+=this.input.slice(chunkStart,this.pos),this.finishToken(tt.symbolExpressionSymbolContent,out));++this.pos}},pp.symbolExpression_readWord=function(){let ch,start=this.pos;do{ch=this.input.charCodeAt(++this.pos)}while(acorn.isIdentifierChar(ch)||45===ch);return this.finishToken(tt.symbolExpressionTagName,this.input.slice(start,this.pos))},pp.symbolExpression_parseString=function(){const value=this.value;return this.next(),value},pp.symbolExpression_parseOpeningTagName=function(){const tagName=this.symbolExpression_parseString();return this.expect(tt.symbolExpressionOpenTagEnd),tagName},pp.symbolExpression_parseClosingTagName=function(){const tagName=this.symbolExpression_parseString();return this.expect(tt.symbolExpressionCloseTagEnd),tagName},pp.symbolExpression_parseElementAt=function(startPos,startLoc){const node=this.startNodeAt(startPos,startLoc);let symbol="";const openingTagName=this.symbolExpression_parseOpeningTagName();let closingTagName="";contents:for(;;)switch(this.type){case tt.symbolExpressionOpenTagStart:symbol+="%",nestingDepth++,this.next();break;case tt.symbolExpressionOpenTagEnd:nestingDepth>0&&(symbol+="%"),this.next();break;case tt.symbolExpressionCloseTagStart:if(this.next(),0===nestingDepth){if(this.eat(tt.slash)){closingTagName=this.symbolExpression_parseClosingTagName();break contents}}else symbol+="%";break;case tt.symbolExpressionCloseTagEnd:nestingDepth>0&&(nestingDepth--,symbol+="%"),this.next();break;case tt.eof:break contents;default:symbol+=this.symbolExpression_parseString()}return closingTagName!==openingTagName&&(nestingDepth=0,this.raise(node.start,"Expected corresponding closing tag for %/"+openingTagName+"%")),node.expression=`%${openingTagName}%${symbol}%/${closingTagName}%`,this.options.plugins.symbolExpression.onSymbolExpression&&this.options.plugins.symbolExpression.onSymbolExpression(node),this.finishNode(node,"SymbolExpression")},pp.symbolExpression_parseElement=function(){let startPos=this.start,startLoc=this.startLoc;return this.next(),this.symbolExpression_parseElementAt(startPos,startLoc)},acorn.plugins.symbolExpression=(instance,options)=>{options&&("object"!=typeof options&&(options={}),Array.isArray(options.onSymbolExpression)&&function(){let symbolExpressions=options.onSymbolExpression;options.onSymbolExpression=expression=>symbolExpressions.push(expression)}(),Array.isArray(options.onCallExpression)&&(()=>{let callExpressions=options.onCallExpression;options.onSymbolExpression=expression=>callExpressions.push(expression)})(),instance.extend("parseExprAtom",function(inner){return function(refShortHandDefaultPos){return this.type===tt.symbolExpressionSymbolContent?this.parseLiteral(this.value):this.type===tt.symbolExpressionOpenTagStart?this.symbolExpression_parseElement():inner.call(this,refShortHandDefaultPos)}}),instance.extend("readToken",function(inner){return function(code){let context=this.curContext();if(context===tc.symbolExpressionExpression)return 37===code?(++this.pos,"/"!==this.input.substr(this.lastTokEnd+1,1)?this.finishToken(tt.symbolExpressionOpenTagStart):this.finishToken(tt.symbolExpressionCloseTagStart)):this.symbolExpression_readToken();if(context===tc.symbolExpressionOpenTag||context===tc.symbolExpressionCloseTag){if(acorn.isIdentifierStart(code))return this.symbolExpression_readWord();if(37===code)return++this.pos,context===tc.symbolExpressionCloseTag?this.finishToken(tt.symbolExpressionCloseTagEnd):this.finishToken(tt.symbolExpressionOpenTagEnd)}return 37===code&&this.exprAllowed?(++this.pos,this.finishToken(tt.symbolExpressionOpenTagStart)):inner.call(this,code)}}),instance.extend("updateContext",function(inner){return function(prevType){return inner.call(this,prevType)}}),instance.extend("finishNode",function(inner){return function(node,type){return"CallExpression"===type&&this.options.plugins.symbolExpression.onCallExpression&&this.options.plugins.symbolExpression.onCallExpression(node),inner.call(this,node,type)}}))};export{};