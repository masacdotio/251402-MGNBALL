import*as TypeHelper from"./Type.Schema.Helper.js";import*as ValueConverter from"../API/ValueConverter.js";export function resolveRefs(schema,source){return source||(source=null),TypeHelper.__resolveRawSchema(schema,source,new Map).schema}export function resolveType(schema){if(schema.convert)return;let schemaType=schema.type;if(!schemaType){let schemaOf=schema.oneOf;if(schemaOf||(schemaOf=schema.anyOf),schemaOf){schemaType=[];for(const s of schemaOf)if(!s.convert){let type2=resolveType(s);if(Array.isArray(type2))for(const subType2 of type2)schemaType.includes(subType2)||schemaType.push(subType2);else type2&&!schemaType.includes(type2)&&schemaType.push(type2)}0===schemaType.length?schemaType=void 0:1===schemaType.length&&(schemaType=schemaType[0])}else schemaType=["string","number","object","boolean","integer","array","null"]}return schemaType}export function resolveTypeConvertRuleSchemaMap(schema){let res=new Map;if(schema.type&&"string"==typeof schema.type)schema.convert&&res.set(schema.type,[schema]);else if(schema.type&&Array.isArray(schema.type)){if(schema.convert)for(let type of schema.type)res.set(type,[schema])}else{let schemaOf=schema.oneOf;if(schemaOf||(schemaOf=schema.anyOf),schemaOf)for(let schema of schemaOf){let ruleSchemas=resolveTypeConvertRuleSchemaMap(schema);ruleSchemas&&ruleSchemas.forEach((value,key)=>{let entry=res.get(key);if(entry)for(let value2 of value)entry.push(value2);else res.set(key,value)})}else{let schemaType=["string","number","object","boolean","integer","array","null"];if(schema.convert)for(let type of schemaType)res.set(type,[schema])}}return res}export function resolveDefault(schema){if(!schema)return null;let targetType,ruleSchemas=resolveTypeConvertRuleSchemaMap(schema);if(schema.default)return tchmi_clone_object(ValueConverter.toSchemaType(schema.default,schema));if(schema.type)if(Array.isArray(schema.type)){let firstType=schema.type[0];firstType&&(targetType=firstType)}else targetType=schema.type;if(targetType&&ruleSchemas){let targetRuleSchemas=ruleSchemas.get(targetType);targetRuleSchemas&&targetRuleSchemas[0].convert&&(targetType=targetRuleSchemas[0].convert)}switch(targetType){case"object":{if(schema.frameworkInstanceOf)return null;let res={};const properties=schema.properties;if(properties)for(const[property,propertySchema]of Object.entries(properties))res[property]=resolveDefault(propertySchema);return res}case"array":{let res=[];const items=schema.items;if(items&&schema.minItems){let itemSchema;itemSchema=Array.isArray(items)?items[0]:items;const value=resolveDefault(itemSchema);for(let i=0;i<schema.minItems;i++)res.push(0===i?value:tchmi_clone_object(value))}return res}case"string":return"";case"integer":case"number":return 0;case"boolean":return!1}return schema.oneOf?resolveDefault(schema.oneOf[0]):schema.anyOf?resolveDefault(schema.anyOf[0]):null}