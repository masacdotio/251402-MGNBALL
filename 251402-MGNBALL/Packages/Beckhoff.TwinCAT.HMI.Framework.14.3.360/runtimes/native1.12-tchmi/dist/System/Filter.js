export class Filter{constructor(logic){this.__logic=logic}__logic;__comparisons=[];__subfilters=[];__parent=null;static __floatEpsilon=Math.pow(2,-23);static parse(data,schema){if(void 0===data)throw new Error("Filter must not be undefined");if(schema&&("array"!==schema.type||!schema.items))throw new Error("Filter schema must describe an array.");if(!data||0===data.length)return new Filter("AND");if(!Array.isArray(data))throw new Error("Filter must be an array.");if(1===data.length){let item=data[0];if(TcHmi.isComparison(item)){let result=new Filter("AND");return schema&&(item=this.__parseComparison(item,schema)),result.__comparisons.push(item),result}if(Array.isArray(item))return this.parse(item,schema);throw new Error("Invalid filter. Expected comparison or nested filter at position 0.")}let first=data[0],second=data[1];if(!TcHmi.isLogicOperator(second))throw new Error("Invalid filter. Expected logic operator at position 1.");let addExpressionToTree=(tree,expression,positionInArray)=>{if(TcHmi.isComparison(expression))schema&&(expression=this.__parseComparison(expression,schema)),tree.__comparisons.push(expression);else{if(!Array.isArray(expression))throw new Error(`Invalid filter. Expected comparison or nested filter at position ${positionInArray}.`);tree.__subfilters.push(this.parse(expression,schema))}},root=new Filter(second.logic);addExpressionToTree(root,first,0);let current=root,currentExpression=null,expecting="comparison";for(let i=2,ii=data.length;i<ii;i++)switch(expecting){case"comparison":currentExpression=data[i],expecting="logic";break;case"logic":let logicOperator=data[i];if(!TcHmi.isLogicOperator(logicOperator))throw new Error(`Invalid filter. Expected logic operator at position ${i}.`);let logic=logicOperator.logic;if(logic===current.__logic)addExpressionToTree(current,currentExpression,i-1);else if("OR"===logic)if(addExpressionToTree(current,currentExpression,i-1),current.__parent&&current.__parent.__logic===logic)current=current.__parent;else{let orTree=new Filter(logic);orTree.__subfilters.push(current),orTree.__parent=current.__parent,current.__parent=orTree,null===orTree.__parent&&(root=orTree),current=orTree}else if("AND"===logic){let andTree=new Filter(logic);addExpressionToTree(andTree,currentExpression,i-1),andTree.__parent=current,current.__subfilters.push(andTree),current=andTree}expecting="comparison"}if("comparison"===expecting)throw new Error("Filter must not end with a logic operator.");return addExpressionToTree(current,currentExpression,data.length-1),root}test(candidate,key=""){for(let i=0,ii=this.__comparisons.length;i<ii;i++){let result=this.__resolveComparison(this.__comparisons[i],candidate,key);if(result&&"OR"===this.__logic)return!0;if(!result&&"AND"===this.__logic)return!1}for(let i=0,ii=this.__subfilters.length;i<ii;i++){let result=this.__subfilters[i].test(candidate,key);if(result&&"OR"===this.__logic)return!0;if(!result&&"AND"===this.__logic)return!1}return"AND"===this.__logic}static __parseComparison(comparison,schema){comparison=tchmi_clone_object(comparison);let findSchema=subschema=>{if(subschema.oneOf)for(let i=0,ii=subschema.oneOf.length;i<ii;i++){let res=findSchema(subschema.oneOf[i]);if(res)return res}else if(subschema.anyOf)for(let i=0,ii=subschema.anyOf.length;i<ii;i++){let res=findSchema(subschema.anyOf[i]);if(res)return res}else if("object"===subschema.type&&subschema.properties){if(subschema.properties.path){if("string"!==subschema.properties.path.type)return null;if(subschema.required?.includes("path")){if(!comparison.path)return null;if(subschema.properties.path.enum&&!subschema.properties.path.enum.includes(comparison.path))return null}}return subschema.properties.comparator&&subschema.properties.comparator.enum&&subschema.properties.comparator.enum.includes(comparison.comparator)&&(subschema.properties.value&&subschema.properties.value.type===typeof comparison.value)?subschema:null}return null},comparisonSchema=null;if(Array.isArray(schema.items))for(let i=0,ii=schema.items.length;i<ii;i++){let res=findSchema(schema.items[i]);if(res){comparisonSchema=res;break}}else schema.items&&(comparisonSchema=findSchema(schema.items));if(comparisonSchema&&comparisonSchema.properties&&"date-time"===comparisonSchema.properties.value.format&&"string"==typeof comparison.value){let date=new Date(comparison.value);if(isNaN(date.getTime()))throw new Error(`Filter contains an invalid date: "${comparison.value}".`);comparison.value=new Date(comparison.value)}return comparison}__resolveComparison(comparison,datum,key){let left,right;try{[left,right]=this.__getValues(comparison,datum,key)}catch(error){return!1}if(void 0===left)return!1;switch(comparison.comparator){case"==":return this.__resolveEquals(left,right);case"!=":return this.__resolveEqualsNot(left,right);case"<":return this.__resolveLessThan(left,right);case">":return this.__resolveGreaterThan(left,right);case"<=":return this.__resolveLessThanOrEquals(left,right);case">=":return this.__resolveGreaterThanOrEquals(left,right);case"contains":return this.__resolveContains(left,right);case"contains not":return this.__resolveContainsNot(left,right);case"== [ignore case]":return this.__resolveEqualsIgnoreCase(left,right);case"!= [ignore case]":return this.__resolveEqualsNotIgnoreCase(left,right);case"contains [ignore case]":return this.__resolveContainsIgnoreCase(left,right);case"contains not [ignore case]":return this.__resolveContainsNotIgnoreCase(left,right)}}__resolveEquals(left,right){return"number"==typeof left&&"number"==typeof right?left===right||Math.abs(left-right)<=Filter.__floatEpsilon:left===right}__resolveEqualsNot(left,right){return!this.__resolveEquals(left,right)}__resolveLessThan(left,right){if("number"==typeof left&&"number"==typeof right)return right-left>Filter.__floatEpsilon;throw new Error(`Cannot compare ${typeof left} with ${typeof right} using <.`)}__resolveGreaterThan(left,right){if("number"==typeof left&&"number"==typeof right)return left-right>Filter.__floatEpsilon;throw new Error(`Cannot compare ${typeof left} with ${typeof right} using >.`)}__resolveLessThanOrEquals(left,right){return!this.__resolveGreaterThan(left,right)}__resolveGreaterThanOrEquals(left,right){return!this.__resolveLessThan(left,right)}__resolveContains(left,right){if("string"==typeof left&&"string"==typeof right)return left.includes(right);if("object"==typeof left&&null!==left){const items=Array.isArray(left)?left:Object.keys(left);for(const item of items)if(this.__resolveEquals(...this.__convert(item,right)))return!0;return!1}throw new Error(`Cannot compare ${typeof left} with ${typeof right} using contains.`)}__resolveContainsNot(left,right){return!this.__resolveContains(left,right)}__resolveEqualsIgnoreCase(left,right){if("string"==typeof left&&"string"==typeof right)return left.toLowerCase()===right.toLowerCase();throw new Error(`Cannot compare ${typeof left} with ${typeof right} using == [ignore case].`)}__resolveEqualsNotIgnoreCase(left,right){return!this.__resolveEqualsIgnoreCase(left,right)}__resolveContainsIgnoreCase(left,right){if("string"==typeof left&&"string"==typeof right)return left.toLowerCase().includes(right.toLowerCase());throw new Error(`Cannot compare ${typeof left} with ${typeof right} using contains [ignore case].`)}__resolveContainsNotIgnoreCase(left,right){return!this.__resolveContainsIgnoreCase(left,right)}__getValues(comparison,datum,key){const[left,right]=this.__convert(this.__followPath(comparison,datum,key),comparison.value,comparison);return[left,right]}__followPath(comparison,datum,key){return comparison.path&&"{value}"!==comparison.path?"{key}"===comparison.path?key:new TcHmi.ObjectPath(comparison.path).readFrom(datum):datum}__convert(left,right,comparison){let cache=!1;if(typeof right!=typeof left)if("string"==typeof right){const isoDateTimeRegex=/^[1-2]\d{3}(-?)[0-1]\d\1[0-3]\d(?:T[0-2]\d(?:(:?)[0-5]\d(?:\2[0-5]\d)?)?(?:[.,]\d+)?(?:Z|[+-][0-1]\d(?::?[0-5]\d)?)?)?$/;switch(typeof left){case"boolean":"true"===right.toLowerCase()?(right=!0,cache=!0):"false"===right.toLowerCase()&&(right=!1,cache=!0);break;case"number":if(/^[+-]?\d*\.?\d+(?:[eE][+-]?\d+)?$/.test(right)){let converted=parseFloat(right);Number.isNaN(converted)||(right=converted,cache=!0)}break;case"object":if(left instanceof Date&&isoDateTimeRegex.test(right)){let converted=new Date(right);Number.isNaN(converted.getTime())||(right=converted,cache=!0)}else null===left&&("null"===right.toLowerCase()?(right=null,cache=!0):isoDateTimeRegex.test(right)&&0===new Date(right).getTime()&&(right=null))}}else void 0!==comparison?.originalValue&&typeof left==typeof comparison.originalValue&&(right=comparison.originalValue);else right instanceof Date&&0===right.getTime()&&null===left&&(right=null);return cache&&comparison&&(comparison.originalValue=comparison.value,comparison.value=right),left instanceof Date&&right instanceof Date&&(left=left.getTime(),right=right.getTime()),[left,right]}}